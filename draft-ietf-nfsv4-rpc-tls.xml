<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc strict="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc
 docName="draft-ietf-nfsv4-rpc-tls-latest"
 category="std"
 updates="5531"
 ipr="pre5378Trust200902"
 submissionType="IETF"
 xml:lang="en">

<front>

<title abbrev="RPC-Over-TLS">
Remote Procedure Call Encryption By Default
</title>

<author initials="T.M." surname="Myklebust" fullname="Trond Myklebust">
<organization abbrev="Hammerspace">
Hammerspace Inc
</organization>
<address>
<postal>
<street>4300 El Camino Real Ste 105</street>
<city>Los Altos</city>
<region>CA</region>
<code>94022</code>
<country>United States of America</country>
</postal>
<email>trond.myklebust@hammerspace.com</email>
</address>
</author>

<author initials="C.L." surname="Lever" fullname="Charles Lever" role="editor">
<organization abbrev="Oracle">Oracle Corporation</organization>
<address>
<postal>
<street></street>
<city></city>
<region></region>
<code></code>
<country>United States of America</country>
</postal>
<email>chuck.lever@oracle.com</email>
</address>
</author>

<date/>

<area>Transport</area>
<workgroup>Network File System Version 4</workgroup>

<abstract>
<t>
This document describes a mechanism that,
through the use of opportunistic Transport Layer Security (TLS),
enables encryption of in-transit Remote Procedure Call (RPC) transactions
while interoperating with ONC RPC implementations
that do not support this mechanism.
This document updates RFC 5531.
</t>
</abstract>

</front>

<middle>

<section
 title="Introduction"
 anchor="section:8f035331-8eb8-4fbc-973a-673fba5fe952">

<t>
In 2014 the IETF published
<xref target="RFC7258"/>
which recognized that unauthorized observation
of network traffic had become widespread and
was a subversive threat to all who
make use of the Internet at large.
It strongly recommended that newly defined Internet
protocols make a real effort to mitigate monitoring attacks.
Typically this mitigation is done by encrypting data in transit.
</t>
<t>
The Remote Procedure Call version 2 protocol
has been a Proposed Standard for three decades
(see <xref target="RFC5531"/> and its antecedants).
Eisler et al. first introduced an in-transit encryption mechanism
for RPC with RPCSEC GSS over twenty years ago
<xref target="RFC2203"/>.
However, experience has shown that RPCSEC GSS
can be difficult to deploy:
<list style="symbols">
<t>
Per-client deployment and administrative costs
are not scalable.
Keying material must be provided for each RPC client,
including transient clients.
</t>
<t>
Parts of each RPC header remain in clear-text,
and can constitute a significant security exposure.
</t>
<t>
Host identity management and user identity management
must be carried out in the same security realm.
In certain environments, different authorities
might be responsible for provisioning client systems versus
provisioning new users.
</t>
<t>
On-host cryptographic manipulation of data payloads can
exact a significant CPU and memory bandwidth cost on RPC peers.
Offloadng does not appear to be practical using GSS privacy
since each message is encrypted using its own key
based on the issuing RPC user.
</t>
</list>
However strong a privacy service is,
it cannot provide any security if the challenges
of using it result in it not being used at all.
</t>
<t>
An alternative approach is to employ a
transport layer security mechanism that can protect the privacy
of each RPC connection transparently to RPC and Upper Layer protocols.
The Transport Layer Security protocol
<xref target="RFC8446"/>
(TLS) is a well-established Internet building block that
protects many common Internet protocols such as
the Hypertext Transport Protocol (http)
<xref target="RFC2818"/>.
</t>
<t>
Encrypting at the RPC transport layer
enables several significant benefits.
<list style="hanging">
<t hangText="Encryption By Default">
<vspace/>
In-transit encryption by itself may be enabled
without additional administrative actions such as
identifying client systems to a trust authority,
generating additional key material, or
provisioning a secure network tunnel.
</t>
<t hangText="Protection of Existing Protocols">
<vspace/>
The imposition of encryption at the transport layer protects
any Upper Layer protocol that employs RPC,
without alteration of that protocol.
RPC transport layer encryption can protect
recent versions of NFS such as NFS version 4.2
<xref target="RFC7862"/>
and indeed legacy NFS versions such as NFS version 3
<xref target="RFC1813"/>,
and NFS side-band protocols such as the MNT protocol
<xref target="RFC1813"/>.
</t>
<t hangText="Decoupled User and Host Identities">
<vspace/>
TLS can be used to authenticate peer hosts
while other security mechanisms can handle user authentictation.
Cryptographic authentication of hosts can be provided while
still using simpler user authentication flavors such as AUTH_SYS.
</t>
<t hangText="Encryption Offload">
<vspace/>
Whereas hardware support for GSS privacy has not appeared
in the marketplace, the use of a well-established
transport encryption mechanism that is also employed
by other very common network protocols
makes it likely that a hardware encryption implementation
will be available to offload encryption and decryption.
A single key protects all messages associated with one TLS session.
</t>
<t hangText="Securing AUTH_SYS">
<vspace/>
Most critically, several security issues inherent
in the current widespread use of AUTH_SYS
(i.e., acceptance of UIDs and GIDs
generated by an unauthenticated client)
can be significantly ameliorated.
</t>
</list>
</t>
<t>
This document specifies the use of RPC on a TLS-protected transport
in a fashion that is transparent to upper layer protocols based on RPC.
It also provides opportunistic policies, in line with
<xref target="RFC7435"/>
that enable RPC-on-TLS to be deployed in environments with implementations that do not support it.
Specifications for RPC-based upper layer protocols are free to require stricter policies
to guarantee that TLS is used for each connection.
</t>
</section>

<section
 title="Requirements Language"
 anchor="section:024237c9-5504-49b4-a2d3-2d2a5efbb967">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted
as described in BCP 14
<xref target="RFC2119"/>
<xref target="RFC8174"/>
when, and only when, they appear in all capitals, as shown here.
</t>
</section>

<section
 title="Terminology"
 anchor="section:0eb1100e-daa8-4b2c-98ae-94258cfdcb1b">
<t>
This document adopts the terminology introduced in Section 3 of
<xref target="RFC6973"/>
and assumes a working knowledge of
the Remote Procedure Call (RPC) version 2 protocol
<xref target="RFC5531"/>
and
the Transport Layer Security (TLS) version 1.3 protocol
<xref target="RFC8446"/>.
</t>
<t>
Note also that the NFS community uses the term "privacy"
where other Internet communities use "confidentiality".
In this document the two terms are synonymous.
</t>
<t>
We cleave to the convention that a "client"
is a network host that actively initiates an association,
and
a "server" is a network host that passively accepts an association request.
</t>
<t>
RPC documentation historically refers to
the authentication of a connecting host as "machine authentication"
or "host authentication".
TLS documentation refers to the same as "peer authentication".
In this document there is little distinction between these terms.
</t>
<t>
The term "user authentication" in this document refers specifically
to the RPC caller's credential, provided in the
"cred"
and
"verf"
fields in each RPC Call.
</t>
</section>

<section
 title="RPC-Over-TLS in Operation"
 anchor="section:ec3feed5-1de0-454b-9ab3-ce47ba901583">

<section
 title="Discovering Server-side TLS Support"
 anchor="section:0a03673b-14ba-4228-8a8a-f76aa318ca73">
<t>
The mechanism described in this document interoperates
fully with RPC implementations that do not support TLS.
The use of TLS is automatically disabled in these cases.
</t>
<t>
To achieve this, we introduce a new RPC authentication flavor called AUTH_TLS.
This new flavor is used to signal that the client wants to initiate
TLS negotiation if the server supports it.
Except for the modifications described in this section,
the RPC protocol is largely unaware of security encapsulation.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

enum auth_flavor {
        AUTH_NONE       = 0,
        AUTH_SYS        = 1,
        AUTH_SHORT      = 2,
        AUTH_DH         = 3,
        AUTH_KERB       = 4,
        AUTH_RSA        = 5,
        RPCSEC_GSS      = 6,
        AUTH_TLS        = 7,

        /* and more to be defined */
};

&lt;CODE ENDS&gt;
</artwork>
</figure>
The length of the opaque data constituting the credential
sent in the call message MUST be zero.
The verifier accompanying the credential MUST be an AUTH_NONE
verifier of length zero.
</t>
<t>
The flavor value of the verifier received in the reply message
from the server MUST be AUTH_NONE.
The bytes of the verifier's string encode the fixed ASCII characters
"STARTTLS".
</t>
<t>
When an RPC client is ready to begin sending traffic to a server,
it starts with a NULL RPC request with an auth_flavor of AUTH_TLS.
The NULL request is made to the same port as if TLS were not in use.
</t>
<t>
The RPC server can respond in one of three ways:
<list style="symbols">
<t>
If the RPC server does not recognise the AUTH_TLS authentication flavor,
it responds with a reject_stat of AUTH_ERROR.
The RPC client then knows that this server does not support TLS.
</t>
<t>
If the RPC server accepts the NULL RPC procedure,
but fails to return an AUTH_NONE verifier containing the
string "STARTTLS",
the RPC client knows that this server does not support TLS.
</t>
<t>
If the RPC server accepts the NULL RPC procedure,
and returns an AUTH_NONE verifier containing the string "STARTTLS",
the RPC client SHOULD send a STARTTLS.
</t>
</list>
</t>
<t>
Once the TLS handshake is complete,
the RPC client and server will have established
a secure channel for communicating.
The client MUST switch to a security flavor other than AUTH_TLS
within that channel, presumably after negotiating down
redundant RPCSEC_GSS privacy and integrity services
and applying channel binding
<xref target="RFC7861"/>.
</t>
<t>
If TLS negotiation fails for any reason --
say, the RPC server rejects the certificate presented by the RPC client,
or the RPC client fails to authenticate the RPC server --
the RPC client reports this failure to the calling application
the same way it would report an AUTH_ERROR rejection from the RPC server.
</t>
<t>
If an RPC client attempts to use AUTH_TLS
for anything other than the NULL RPC procedure,
the RPC server MUST respond with a reject_stat of AUTH_ERROR.
If the client sends a STARTTLS after it has sent other
non-encrypted RPC traffic or after a TLS session has
already been negotiated, the server MUST silently discard it.
</t>
</section>

<section
 title="Authentication"
 anchor="section:6edef553-c95a-47d7-abba-0b537fe3a959">
<t>
Both RPC and TLS have their own variants of authentication,
and there is some overlap in capability.
The goal of interoperability with implementations that do not
support TLS requires that we limit the
combinations that are allowed and precisely specify the
role that each layer plays.
We also want to handle TLS such that an RPC implementation can
make the use of TLS invisible to existing RPC consumer applications.
</t>
<t>
Depending on its configuration,
an RPC server MAY request a TLS peer identity from each client
upon first contact.
This permits two different modes of deployment:
<list style="hanging">
<t hangText="Server-only Host Authentication">
<vspace/>
A server possesses a unique global identity
(e.g., a certificate that is signed by a well-known trust anchor)
while its clients are anonymous
(i.e., present no identifier).
In this situation, the client SHOULD authenticate the server host
using the presented TLS identity,
but the server cannot authenticate clients.
</t>
<t hangText="Mutual Host Authentication">
<vspace/>
In this type of deployment,
both the server and its clients possess unique identities
(e.g., certificates).
As part of the TLS handshake, both peers SHOULD authenticate
using the presented TLS identities.
Should authentication of either peer fail,
or should authorization based on those identities block access
to the server, the client association MAY be rejected.
</t>
</list>
</t>
<t>
In either of these modes, RPC user authentication is not affected
by the use of transport layer security.
Once a TLS session is established,
the server MUST NOT utilize the client peer's TLS identity
for the purpose of authorizing individual RPC requests.
</t>

<section
 title="Using TLS with RPCSEC GSS"
 anchor="section:12d92596-f310-48c8-a4e0-b6ca038524e5">
<t>
RPCSEC GSS can provide per-request
integrity
or
privacy (also known as confidentiality) services.
When operating over a TLS session, these services become redundant.
Each RPC implementation is responsible for using channel binding
for detecting when GSS integrity or privacy is unnecessary and can
therefore be disabled.
See Section 2.5 of <xref target="RFC7861"/> for details.
</t>
<t>
Note that a GSS service principal is still required on the server,
and mutual GSS authentication of server and client still occurs after
the TLS session is established.
</t>
</section>

</section>

</section>

<section
 title="TLS Requirements"
 anchor="section:D93526DA-7B9D-419B-BE84-4AD8DA48577E">
<t>
When a TLS session is negotiated for the purpose of transporting RPC,
the following restrictions apply:
<list style="symbols">
<t>
Implementations MUST NOT negotiate TLS versions prior to v1.3
<xref target="RFC8446"/>.
Support for mandatory-to-implement ciphersuites for
the negotiated TLS version is REQUIRED.
</t>
<t>
Implementations MUST support certificate-based mutual authentication.
Support for TLS-PSK mutual authentication
<xref target="RFC4279"/>
is OPTIONAL.
See
<xref target="section:6edef553-c95a-47d7-abba-0b537fe3a959"/>
for further details.
</t>
<t>
Negotiation of a ciphersuite providing for confidentiality as
well as integrity protection is REQUIRED.
Support for and negotiation of compression is OPTIONAL.
</t>
</list>
</t>

<section
 title="Base Transport Considerations"
 anchor="section:cc204592-f561-49bd-b1c9-de0ff7f0e7ab">

<section
 title="Operation on TCP"
 anchor="section:74B43C7E-5ADC-4FBD-B4EA-FF8F470994A8">
<t>
RPC over TCP is protected by using TLS
<xref target="RFC8446"/>.
As soon as a client completes the TCP handshake,
it uses the mechanism described in
<xref target="section:0a03673b-14ba-4228-8a8a-f76aa318ca73"/>
to discover TLS support and then negotiate a TLS session.
</t>
<t>
After the TLS session is established,
all traffic on the connection
is encapsulated and protected
until the TLS session is terminated.
This includes reverse-direction operations
(i.e., RPC requests initiated on the server-end of the connection).
A reverse-direction operation sent on a connection outside
of its existing TLS session MUST fail with a reject_stat of AUTH_ERROR.
</t>
<t>
An RPC peer terminates a TLS session by sending a TLS closure alert,
or by closing the underlying TCP socket.
After TLS session termination,
any subsequent RPC request over the same connection
MUST fail with a reject_stat of AUTH_ERROR.
</t>
</section>

<section
 title="Operation on UDP"
 anchor="section:B8BF600E-96DC-4C82-AADF-D593826E9B75">
<t>
RPC over UDP is protected using DTLS
<xref target="RFC6347"/>.
As soon as a client initializes a socket for use with
an unfamiliar server,
it uses the mechanism described in
<xref target="section:0a03673b-14ba-4228-8a8a-f76aa318ca73"/>
to discover DTLS support and then negotiate a DTLS session.
Connected operation is RECOMMENDED.
</t>
<t>
Using a DTLS transport does not introduce reliable or in-order
semantics to RPC on UDP.
Also, DTLS does not support fragmentation of RPC messages.
One RPC message fits in a single DTLS datagram.
DTLS encapsulation has overhead which reduces the effective
Path MTU (PMTU) and thus the maximum RPC payload size.
</t>
<t>
DTLS does not detect STARTTLS replay.
A DTLS session can be terminated by sending a TLS closure alert.
Subsequent RPC messages passing between the client and server
will no longer be protected until a new TLS session is established.
</t>
</section>

<section
 title="Operation on an RDMA Transport"
 anchor="section:BFCC24B1-E6D4-4ABC-A5F3-B71E8E96878F">
<t>
RPC-over-RDMA
can make use of Transport Layer Security below the RDMA transport layer
<xref target="RFC8166"/>.
The exact mechanism is not within the scope of this document.
</t>
</section>

</section>

<section
 title="TLS Peer Authentication"
 anchor="section:936921ed-67bb-46bf-b316-6740e07f6652">
<t>
Peer authentication can be performed by TLS using any of the
following mechanisms:
</t>

<section
 title="X.509 Certificates Using PKIX trust"
 anchor="section:7A68F518-2C02-4705-8218-4F13E51372F4">
<t>
Implementations are REQUIRED to support this mechanism.
In this mode, an RPC peer is uniquely identified
by the tuple (serial number of presented certificate;Issuer).
<list style="symbols">
<t>
Implementations MUST allow the configuration of a list of
trusted Certification Authorities for incoming connections.
</t>
<t>
Certificate validation MUST include the verification rules as per
<xref target="RFC5280"/>.
</t>
<t>
Implementations SHOULD indicate their trusted Certification
Authorities (CAs).
</t>
<t>
Peer validation always includes a check on whether the
locally configured expected DNS name or IP address of the
server that is contacted matches its presented certificate.
DNS names and IP addresses can be contained in the Common
Name (CN) or subjectAltName entries.
For verification, only one of these entries is to be considered.
The following precedence applies: for DNS name validation,
subjectAltName:DNS has precedence over CN; for IP address
validation, subjectAltName:iPAddr has precedence over CN.
Implementors of this specification are advised to read
Section 6 of
<xref target="RFC6125"/>
for more details on DNS name validation.
</t>
<t>
Implementations MAY allow the configuration of a set of
additional properties of the certificate to check for a
peer's authorization to communicate
(e.g., a set of allowed values in subjectAltName:URI
or a set of allowed X509v3 Certificate Policies).
</t>
<t>
When the configured trust base changes (e.g., removal of a
CA from the list of trusted CAs; issuance of a new CRL for
a given CA), implementations MAY renegotiate the TLS
session to reassess the connecting peer's continued
authorization.
</t>
</list>
</t>
<t>
Authenticating a connecting entity does not mean the
RPC server necessarily wants to communicate with that client.
For example, if the Issuer is not in a trusted set of Issuers,
the RPC server may decline to perform RPC transactions
with this client.
Implementations that want to support a wide variety of trust models
should expose as many details of the presented certificate to the
administrator as possible so that the trust model can be implemented
by the administrator.
As a suggestion, at least the following
parameters of the X.509 client certificate should be exposed:
<list style="symbols">
<t>
Originating IP address
</t>
<t>
Certificate Fingerprint
</t>
<t>
Issuer
</t>
<t>
Subject
</t>
<t>
all X509v3 Extended Key Usage
</t>
<t>
all X509v3 Subject Alternative Name
</t>
<t>
all X509v3 Certificate Policies
</t>
</list>
</t>
</section>

<section
 title="X.509 Certificates Using Fingerprints"
 anchor="section:15B9BEE9-9D2F-49B7-900E-0BA9BCE9CB27">
<t>
This mechanism is OPTIONAL to implement.
In this mode, an RPC peer is uniquely identified
by the fingerprint of the presented certificate.
</t>
<t>
Implementations SHOULD allow the configuration of a list
of trusted certificates,
identified via fingerprint of the DER encoded certificate octets.
Implementations MUST support SHA-1 as the hash algorithm for the
fingerprint.
To prevent attacks based on hash collisions,
support for a more contemporary hash function,
such as SHA-256, is RECOMMENDED.
</t>
</section>

<section
 title="Pre-Shared Keys"
 anchor="section:6DA9ED5F-BAD9-4126-95B7-E2331655A01E">
<t>
This mechanism is OPTIONAL to implement.
In this mode, an RPC peer is uniquely identified by key material
that has been shared out-of-band or by a previous TLS-protected
connection (see
<xref target="RFC8446"/> Section 2.2).
At least the following parameters of the TLS connection should be exposed:
<list style="symbols">
<t>
Originating IP address
</t>
<t>
TLS Identifier
</t>
</list>
</t>
</section>

<section
 title="Token Binding"
 anchor="section:CBA3E016-B160-4C37-85CA-8D467A6AFE83">
<t>
This mechanism is OPTIONAL to implement.
In this mode, an RPC peer is uniquely identified by a token.
</t>
<t>
Versions of TLS subsequent to TLS 1.2 feature a token binding
mechanism which is nominally more secure than using certificates.
This is discussed in further detail in
<xref target="RFC8471"/>.
</t>
</section>

</section>

</section>

<!-- RFC Editor:
Please remove the following section and the reference to RFC 7942
before this document is published.
-->
<section
 title="Implementation Status"
 anchor="section:88BBA4D6-ED42-4FE6-A208-9D277B68729A">
<t>
This section records the status of known implementations of the
protocol defined by this specification at the time of posting of
this Internet-Draft, and is based on a proposal described in
<xref target="RFC7942"/>.
The description of implementations in this section is
intended to assist the IETF in its decision processes in
progressing drafts to RFCs.
</t>
<t>
Please note that the listing of any individual implementation here
does not imply endorsement by the IETF.
Furthermore, no effort has been spent to verify the information
presented here that was supplied by IETF contributors.
This is not intended as, and must not be construed to be, a
catalog of available implementations or their features.
Readers are advised to note that other implementations may exist.
</t>

<section
 title="DESY NFS server"
 anchor="section:94AA7844-E393-4353-A35D-DA01D13C909B">
<t>
<list style="hanging" hangIndent="11">
<t hangText="Organization:">
DESY
</t>
<t hangText="URL:">
https://desy.de
</t>
<t hangText="Maturity:">
Prototype software based on early versions of this document.
</t>
<t hangText="Coverage:">
The bulk of this specification is implemented.
The use of DTLS functionality is not implemented.
</t>
<t hangText="Licensing:">
LGPL
</t>
<t hangText="Implementation experience:">
No comments from implementors.
</t>
</list>
</t>
</section>

<section
 title="Hammerspace NFS server"
 anchor="section:B387F281-958F-470D-B4D4-1D85907B89F1">
<t>
<list style="hanging" hangIndent="11">
<t hangText="Organization:">
Hammerspace
</t>
<t hangText="URL:">
https://hammerspace.com
</t>
<t hangText="Maturity:">
Prototype software based on early versions of this document.
</t>
<t hangText="Coverage:">
The bulk of this specification is implemented.
The use of DTLS functionality is not implemented.
</t>
<t hangText="Licensing:">
Proprietary
</t>
<t hangText="Implementation experience:">
No comments from implementors.
</t>
</list>
</t>
</section>

<section
 title="Linux NFS server and client"
 anchor="section:BF03B3A2-4483-4404-9E7A-F60FCD850F31">
<t>
<list style="hanging" hangIndent="11">
<t hangText="Organization:">
The Linux Foundation
</t>
<t hangText="URL:">
https://www.kernel.org
</t>
<t hangText="Maturity:">
Prototype software based on early versions of this document.
</t>
<t hangText="Coverage:">
The bulk of this specification is implemented.
The use of DTLS functionality is not implemented.
</t>
<t hangText="Licensing:">
GPLv2
</t>
<t hangText="Implementation experience:">
No comments from implementors.
</t>
</list>
</t>
</section>

</section>

<section
 title="Security Considerations"
 anchor="section:2ae49383-e6b2-4830-8407-995febf727f2">
<t>
One purpose of the mechanism described in this document
is to protect RPC-based applications against threats to
the privacy of RPC transactions and RPC user identities.
A taxonomy of these threats appears in Section 5 of
<xref target="RFC6973"/>.
In addition, Section 6 of
<xref target="RFC7525"/>
contains a detailed discussion
of technologies used in conjunction with TLS.
Implementers should familiarize themselves with these materials.
</t>

<section
 title="Limitations of an Opportunistic Approach"
 anchor="section:51737BB5-2B65-441E-AD1D-7EBF5123C079">
<t>
A range of options is allowed by the opportunistic approach
described in this document,
from
"no peer authentication or encryption"
to
"server-only authentication with encryption"
to
"mutual authentication with encryption".
The security level may indeed be selected
without user intervention based on a policy.
Implementations must take care to accurately represent
to all RPC consumers
the level of security that is actually in effect.
</t>
</section>

<section
 title="STRIPTLS Attacks"
 anchor="section:8894bdd2-0e0b-47a3-a2cb-70e4d93b55b0">
<t>
A classic form of attack on network protocols that initiate an association
in plain-text to discover support for TLS is a man-in-the-middle
that alters the plain-text handshake to make it appear as though
TLS support is not available on one or both peers.
Clients implementers can choose from the following to mitigate
STRIPTLS attacks:
<list style="symbols">
<t>
Client security policy can be configured to require
that a TLS session is established on every connection.
If an attacker spoofs the handshake, the client disconnects
and reports the problem.
This approach is RECOMMENDED.
</t>
<t>
A TLSA record
<xref target="RFC6698"/>
can alert clients that TLS is expected to work, and
provides a binding of hostname to x.509 identity.
If TLS cannot be negotiated or authentication fails,
the client disconnects and reports the problem.
</t>
</list>
</t>
</section>

<section
 title="Implications for AUTH_SYS"
 anchor="section:552b02a0-f19e-4b46-809c-672a6ae931a1">
<t>
Ever since the IETF NFSV4 Working Group took over
the maintenance of the NFSv4 family of protocols
(currently specified in
<xref target="RFC7530"/>,
<xref target="RFC5661"/>,
and
<xref target="RFC7863"/>,
among others),
it has encouraged the use of RPCSEC GSS rather than AUTH_SYS.
For various reasons, AUTH_SYS continues to be
the primary authentication mechanism deployed by NFS administrators.
As a result, NFS security remains in an unsatisfactory state.
</t>
<t>
A deeper purpose of this document is to attempt to address
some of the shortcomings of AUTH_SYS so that,
where it has been impractical to deploy RPCSEC GSS,
better NFSv4 security can nevertheless be achieved.
</t>
<t>
When AUTH_SYS is used with TLS and no client certificate is available,
the RPC server is still acting on RPC requests for which there is
no trustworthy authentication.
In-transit traffic is protected, but the client itself can still
misrepresent user identity without detection.
This is an improvement from AUTH_SYS without encryption, but it
leaves a critical security exposure.
</t>
<t>
Therefore, the RECOMMENDED deployment mode is that
clients have certificate material configured and used
so that servers can have a degree of trust
that clients are acting responsibly.
</t>
</section>

<section
 title="Multiple User Identity Realms"
 anchor="section:B9F8A982-CB0E-40FC-9460-680E89DB0001">
<t>
In circumstances where the RPC users on a single client belong
to multiple distinct security realms,
the client MUST establish an independent TLS session
for each user identity realm.
</t>
</section>

</section>

<section
 title="IANA Considerations"
 anchor="section:7b126473-2a13-453b-9bca-66bc11b7b018">
<t>
In accordance with Section 6 of
<xref target="RFC7301"/>,
the authors request that IANA allocate the following value
in the "Application-Layer Protocol Negotiation (ALPN) Protocol IDs" registry.
The "sunrpc" string identifies SunRPC when used over TLS.
<list style="hanging">
<t hangText="Protocol:">
<vspace/>
SunRPC
</t>
<t hangText="Identification Sequence:">
<vspace/>
0x73 0x75 0x6e 0x72 0x70 0x63 ("sunrpc")
</t>
<t hangText="Reference:">
<vspace/>
RFC-TBD
</t>
</list>
</t>
<!-- RFC Editor:
Please replace RFC-TBD with the RFC number assigned to this document.
-->
</section>

</middle>

<back>

<references title="Normative References">
<?rfc include="reference.RFC.2119.xml"?>
<?rfc include="reference.RFC.4279.xml"?>
<?rfc include="reference.RFC.5280.xml"?>
<?rfc include="reference.RFC.5531.xml"?>
<?rfc include="reference.RFC.6125.xml"?>
<?rfc include="reference.RFC.6347.xml"?>
<?rfc include="reference.RFC.7258.xml"?>
<?rfc include="reference.RFC.7301.xml"?>
<?rfc include="reference.RFC.7861.xml"?>
<?rfc include="reference.RFC.7942.xml"?>.
<?rfc include="reference.RFC.8174.xml"?>
<?rfc include="reference.RFC.8446.xml"?>
</references>

<references title="Informative References">

<?rfc include="reference.RFC.1813.xml"?>
<?rfc include="reference.RFC.2203.xml"?>
<?rfc include="reference.RFC.2818.xml"?>
<?rfc include="reference.RFC.5661.xml"?>
<?rfc include="reference.RFC.6698.xml"?>
<?rfc include="reference.RFC.6973.xml"?>
<?rfc include="reference.RFC.7435.xml"?>
<?rfc include="reference.RFC.7525.xml"?>
<?rfc include="reference.RFC.7530.xml"?>
<?rfc include="reference.RFC.7862.xml"?>
<?rfc include="reference.RFC.7863.xml"?>
<?rfc include="reference.RFC.8166.xml"?>
<?rfc include="reference.RFC.8471.xml"?>

</references>

<section
 title="Acknowledgments"
 anchor="section:4959412f-37ad-42b8-9169-d477148f81a8"
 numbered="no">
<t>
Special mention goes to Charles Fisher, author of
<eref
 target="https://www.linuxjournal.com/content/encrypting-nfsv4-stunnel-tls">
"Encrypting NFSv4 with Stunnel TLS"
</eref>.
His article inspired the mechanism described in this document.
</t>
<t>
Many thanks to Tigran Mkrtchyan for his work on the DESY prototype
and resulting feedback to this document.
</t>
<t>
The authors are grateful to
Bill Baker,
David Black,
Alan DeKok,
Lars Eggert,
Benjamin Kaduk,
Olga Kornievskaia,
Greg Marsden,
Alex McDonald,
David Noveck,
Justin Mazzola Paluska,
Tom Talpey,
and
Martin Thomson
for their input and support of this work.
</t>
<t>
Lastly, special thanks go to
Transport Area Director Magnus Westerlund,
NFSV4 Working Group Chairs Spencer Shepler and Brian Pawlowski,
and
NFSV4 Working Group Secretary Thomas Haynes
for their guidance and oversight.
</t>
</section>

</back>

</rfc>
