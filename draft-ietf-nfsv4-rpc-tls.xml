<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<?rfc strict="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc
 docName="draft-ietf-nfsv4-rpc-tls-latest"
 category="std"
 updates="5531"
 ipr="pre5378Trust200902"
 submissionType="IETF"
 xml:lang="en">

<front>

<title abbrev="RPC-Over-TLS">
Towards Remote Procedure Call Encryption By Default
</title>

<author initials="T.M." surname="Myklebust" fullname="Trond Myklebust">
<organization abbrev="Hammerspace">
Hammerspace Inc
</organization>
<address>
<postal>
<street>4300 El Camino Real Ste 105</street>
<city>Los Altos</city>
<region>CA</region>
<code>94022</code>
<country>United States of America</country>
</postal>
<email>trond.myklebust@hammerspace.com</email>
</address>
</author>

<author initials="C.L." surname="Lever" fullname="Charles Lever" role="editor">
<organization abbrev="Oracle">Oracle Corporation</organization>
<address>
<postal>
<street></street>
<city></city>
<region></region>
<code></code>
<country>United States of America</country>
</postal>
<email>chuck.lever@oracle.com</email>
</address>
</author>

<date/>

<area>Transport</area>
<workgroup>Network File System Version 4</workgroup>

<abstract>
<t>
This document describes a mechanism that,
through the use of opportunistic Transport Layer Security (TLS),
enables encryption of in-transit Remote Procedure Call (RPC) transactions
while interoperating with ONC RPC implementations
that do not support this mechanism.
This document updates RFC 5531.
</t>
</abstract>

</front>

<middle>

<section
 title="Introduction"
 anchor="section:8f035331-8eb8-4fbc-973a-673fba5fe952">

<t>
In 2014 the IETF published
<xref target="RFC7258"/>
which recognized that unauthorized observation
of network traffic had become widespread and
was a subversive threat to all who
make use of the Internet at large.
It strongly recommended that newly defined Internet
protocols make a real effort to mitigate monitoring attacks.
Typically this mitigation is done by encrypting data in transit.
</t>
<t>
The Remote Procedure Call version 2 protocol
has been a Proposed Standard for three decades
(see <xref target="RFC5531"/> and its antecedants).
Over twenty years ago,
Eisler et al. first introduced RPCSEC GSS
as an in-transit encryption mechanism for RPC
<xref target="RFC2203"/>.
However, experience has shown that
RPCSEC GSS with in-transit encryption
can be challenging to use in practice:
<list style="symbols">
<t>
Parts of each RPC header remain in clear-text,
constituting a significant security exposure.
</t>
<t>
On-host cryptographic manipulation of data payloads can
exact a significant CPU and memory bandwidth cost on RPC peers.
Offloadng does not appear to be practical using GSS privacy
since each message is encrypted using its own key
based on the issuing RPC user.
</t>
</list>
However strong a privacy service is,
it cannot provide any security if the challenges
of using it result in choosing not to deploy it at all.
</t>
<t>
Moreover, the use of AUTH_SYS remains common
despite the negative effects
that acceptance of UIDs and GIDs
from unauthenticated clients brings with it.
This is in part because:
<list style="symbols">
<t>
Per-client deployment and administrative costs
are not scalable.
Keying material must be provided for each RPC client,
including transient clients.
</t>
<t>
Host identity management and user identity management
must be carried out in the same security realm.
In certain environments, different authorities
might be responsible for provisioning client systems versus
provisioning new users.
</t>
</list>
</t>
<t>
The alternative described in this document is to employ a
transport layer security mechanism that can protect the privacy
of each RPC connection transparently to RPC and Upper Layer protocols.
The Transport Layer Security protocol
<xref target="RFC8446"/>
(TLS) is a well-established Internet building block that
protects many common Internet protocols such as
the Hypertext Transport Protocol (http)
<xref target="RFC2818"/>.
</t>
<t>
Encrypting at the RPC transport layer enables several significant benefits.
<list style="hanging">
<t hangText="Encryption By Default">
<vspace/>
In-transit encryption by itself may be enabled
without additional administrative actions such as
identifying client systems to a trust authority,
generating additional key material, or
provisioning a secure network tunnel.
</t>
<t hangText="Encryption Offload">
<vspace/>
Whereas hardware support for GSS privacy has not appeared
in the marketplace, the use of a well-established
transport encryption mechanism that is also employed
by other very common network protocols
makes it likely that a hardware encryption implementation
will be available to offload encryption and decryption.
</t>
<t hangText="Securing AUTH_SYS">
<vspace/>
Most critically, several security issues inherent
in the current widespread use of AUTH_SYS
(i.e., acceptance of UIDs and GIDs
generated by an unauthenticated client)
can be significantly ameliorated.
</t>
<t hangText="Decoupled User and Host Identities">
<vspace/>
TLS can be used to authenticate peer hosts
while other security mechanisms can handle user authentictation.
Cryptographic authentication of hosts can be provided while
safely using simpler user authentication flavors such as AUTH_SYS.
</t>
</list>
</t>
<t>
This document specifies the use of RPC on a TLS-protected transport
in a fashion that is transparent to upper layer protocols based on RPC.
The imposition of encryption at the transport layer protects
any Upper Layer protocol that employs RPC,
without alteration of that protocol.
</t>
<t>
In addition, this document provides policies in line with
<xref target="RFC7435"/>
that enable RPC-on-TLS to be deployed opportunistically
in environments with RPC implementations that do not support TLS.
Specifications for RPC-based upper layer protocols
are free to require stricter policies to guarantee that
TLS with encryption
or
TLS with host authentication and encryption
is used for every connection.
</t>
<t>
Note that the protocol specification in this document assumes that
support for RPC, TLS, PKI, GSS-API, and/or DNSSEC is
already available in an implementation where RPC-on-TLS is to be added.
</t>
</section>

<section
 title="Requirements Language"
 anchor="section:024237c9-5504-49b4-a2d3-2d2a5efbb967">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted
as described in BCP 14
<xref target="RFC2119"/>
<xref target="RFC8174"/>
when, and only when, they appear in all capitals, as shown here.
</t>
</section>

<section
 title="Terminology"
 anchor="section:0eb1100e-daa8-4b2c-98ae-94258cfdcb1b">
<t>
This document adopts the terminology introduced in Section 3 of
<xref target="RFC6973"/>
and assumes a working knowledge of
the Remote Procedure Call (RPC) version 2 protocol
<xref target="RFC5531"/>
and
the Transport Layer Security (TLS) version 1.3 protocol
<xref target="RFC8446"/>.
</t>
<t>
Note also that the NFS community uses the term "privacy"
where other Internet communities use "confidentiality".
In this document the two terms are synonymous.
</t>
<t>
We adhere to the convention that a "client"
is a network host that actively initiates an association,
and
a "server" is a network host that passively accepts an association request.
</t>
<t>
RPC documentation historically refers to
the authentication of a connecting host as "machine authentication"
or "host authentication".
TLS documentation refers to the same as "peer authentication".
In this document there is little distinction between these terms.
</t>
<t>
The term "user authentication" in this document refers specifically
to the RPC caller's credential, provided in the
"cred"
and
"verf"
fields in each RPC Call.
</t>
</section>

<section
 title="RPC-Over-TLS in Operation"
 anchor="section:ec3feed5-1de0-454b-9ab3-ce47ba901583">

<section
 title="Discovering Server-side TLS Support"
 anchor="section:0a03673b-14ba-4228-8a8a-f76aa318ca73">
<t>
The mechanism described in this document interoperates
fully with RPC implementations that do not support TLS.
The use of TLS is automatically disabled in these cases.
</t>
<t>
To achieve this, we introduce a new RPC authentication flavor called AUTH_TLS.
This new flavor is used to signal that the client wants to initiate
TLS negotiation if the server supports it.
Except for the modifications described in this section,
the RPC protocol is largely unaware of security encapsulation.
<figure align="left">
<artwork xml:space="preserve" align="left">
&lt;CODE BEGINS&gt;

enum auth_flavor {
        AUTH_NONE       = 0,
        AUTH_SYS        = 1,
        AUTH_SHORT      = 2,
        AUTH_DH         = 3,
        AUTH_KERB       = 4,
        AUTH_RSA        = 5,
        RPCSEC_GSS      = 6,
        AUTH_TLS        = 7,

        /* and more to be defined */
};

&lt;CODE ENDS&gt;
</artwork>
</figure>
The length of the opaque data constituting the credential
sent in the call message MUST be zero.
The verifier accompanying the credential MUST be an AUTH_NONE
verifier of length zero.
</t>
<t>
The flavor value of the verifier received in the reply message
from the server MUST be AUTH_NONE.
The bytes of the verifier's string encode the fixed ASCII characters
"STARTTLS".
</t>
<t>
When an RPC client is ready to begin sending traffic to a server,
it starts with a NULL RPC request with an auth_flavor of AUTH_TLS.
The NULL request is made to the same port as if TLS were not in use.
</t>
<t>
The RPC server can respond in one of three ways:
<list style="symbols">
<t>
If the RPC server does not recognise the AUTH_TLS authentication flavor,
it responds with a reject_stat of AUTH_ERROR.
The RPC client then knows that this server does not support TLS.
</t>
<t>
If the RPC server accepts the NULL RPC procedure,
but fails to return an AUTH_NONE verifier containing the
string "STARTTLS",
the RPC client knows that this server does not support TLS.
</t>
<t>
If the RPC server accepts the NULL RPC procedure,
and returns an AUTH_NONE verifier containing the string "STARTTLS",
the RPC client SHOULD send a STARTTLS.
</t>
</list>
</t>
<t>
Once the TLS handshake is complete,
the RPC client and server will have established
a secure channel for communicating.
The client MUST switch to a security flavor other than AUTH_TLS
within that channel, presumably after negotiating down
redundant RPCSEC_GSS privacy and integrity services
and applying channel binding
<xref target="RFC7861"/>.
</t>
<t>
If TLS negotiation fails for any reason --
say, the RPC server rejects the certificate presented by the RPC client,
or the RPC client fails to authenticate the RPC server --
the RPC client reports this failure to the calling application
the same way it would report an AUTH_ERROR rejection from the RPC server.
</t>
<t>
If an RPC client attempts to use AUTH_TLS
for anything other than the NULL RPC procedure,
the RPC server MUST respond with a reject_stat of AUTH_ERROR.
If the client sends a STARTTLS after it has sent other
non-encrypted RPC traffic or after a TLS session has
already been negotiated, the server MUST silently discard it.
</t>
</section>

<section
 title="Authentication"
 anchor="section:6edef553-c95a-47d7-abba-0b537fe3a959">
<t>
Both RPC and TLS have their own variants of authentication,
and there is some overlap in capability.
The goal of interoperability with implementations that do not
support TLS requires that we limit the
combinations that are allowed and precisely specify the
role that each layer plays.
We also want to handle TLS such that an RPC implementation can
make the use of TLS invisible to existing RPC consumer applications.
</t>
<t>
Each RPC server that supports RPC-over-TLS MUST possess a unique global identity
(e.g., a certificate that is signed by a well-known trust anchor).
Such an RPC server MUST request a TLS peer identity from each client
upon first contact.
There are two different modes of client deployment:
<list style="hanging">
<t hangText="Server-only Host Authentication">
<vspace/>
In this type of deployment, RPC-over-TLS clients are essentially anonymous;
i.e., they present no globally unique identifier to the server peer.
In this situation, the client can authenticate the server host
using the presented server peer TLS identity,
but the server cannot authenticate the client.
</t>
<t hangText="Mutual Host Authentication">
<vspace/>
In this type of deployment,
the client possesses a unique global identity
(e.g., a certificate).
As part of the TLS handshake, both peers authenticate
using the presented TLS identities.
If authentication of either peer fails,
or if authorization based on those identities blocks access
to the server, the client association MUST be rejected.
</t>
</list>
</t>
<t>
In either of these modes, RPC user authentication is not affected
by the use of transport layer security.
Once a TLS session is established,
the server MUST NOT substitute RPC_AUTH_TLS,
or the remote identity used for TLS peer authentication,
for existing forms of per-request RPC user authentication
specified by
<xref target="RFC5531"/>.
</t>

<section
 title="Using TLS with RPCSEC GSS"
 anchor="section:12d92596-f310-48c8-a4e0-b6ca038524e5">
<t>
RPCSEC GSS can provide per-request
integrity
or
privacy (also known as confidentiality) services.
When operating over a TLS session, these services become redundant.
A TLS-capable RPC implementation uses GSS channel binding
for detecting when GSS integrity or privacy is unnecessary and can
therefore be avoided.
See Section 2.5 of <xref target="RFC7861"/> for details.
</t>
<t>
When employing GSS above TLS,
a GSS service principal is still required on the server,
and GSS mutual authentication still occurs after
the TLS session is established.
</t>
</section>

</section>

</section>

<section
 title="TLS Requirements"
 anchor="section:D93526DA-7B9D-419B-BE84-4AD8DA48577E">
<t>
When a TLS session is negotiated for the purpose of transporting RPC,
the following restrictions apply:
<list style="symbols">
<t>
Implementations MUST NOT negotiate TLS versions prior to v1.3
<xref target="RFC8446"/>.
Support for mandatory-to-implement ciphersuites for
the negotiated TLS version is REQUIRED.
</t>
<t>
Implementations MUST support certificate-based mutual authentication.
Support for TLS-PSK mutual authentication
<xref target="RFC4279"/>
is OPTIONAL.
See
<xref target="section:6edef553-c95a-47d7-abba-0b537fe3a959"/>
for further details.
</t>
<t>
Negotiation of a ciphersuite providing for confidentiality as
well as integrity protection is REQUIRED.
Support for and negotiation of compression is OPTIONAL.
</t>
</list>
</t>

<section
 title="Base Transport Considerations"
 anchor="section:cc204592-f561-49bd-b1c9-de0ff7f0e7ab">

<section
 title="Operation on TCP"
 anchor="section:74B43C7E-5ADC-4FBD-B4EA-FF8F470994A8">
<t>
RPC over TCP is protected by using TLS
<xref target="RFC8446"/>.
As soon as a client completes the TCP handshake,
it uses the mechanism described in
<xref target="section:0a03673b-14ba-4228-8a8a-f76aa318ca73"/>
to discover TLS support and then negotiate a TLS session.
</t>
<t>
After the TLS session is established,
all traffic on the connection
is encapsulated and protected
until the TLS session is terminated.
This includes reverse-direction operations
(i.e., RPC requests initiated on the server-end of the connection).
An RPC client receiving a reverse-direction operation
on a connection outside of an existing TLS session MUST reject
the request with a reject_stat of AUTH_ERROR.
</t>
<t>
An RPC peer terminates a TLS session by sending a TLS closure alert,
or by closing the underlying TCP socket.
After TLS session termination,
a recipient MUST reject any subsequent RPC requests over the
same connection with a reject_stat of AUTH_ERROR.
</t>
</section>

<section
 title="Operation on UDP"
 anchor="section:B8BF600E-96DC-4C82-AADF-D593826E9B75">
<t>
RPC over UDP is protected using DTLS
<xref target="RFC6347"/>.
As soon as a client initializes a socket for use with
an unfamiliar server,
it uses the mechanism described in
<xref target="section:0a03673b-14ba-4228-8a8a-f76aa318ca73"/>
to discover DTLS support and then negotiate a DTLS session.
Connected operation is RECOMMENDED.
</t>
<t>
Using a DTLS transport does not introduce reliable or in-order
semantics to RPC on UDP.
Also, DTLS does not support fragmentation of RPC messages.
One RPC message fits in a single DTLS datagram.
DTLS encapsulation has overhead which reduces the effective
Path MTU (PMTU) and thus the maximum RPC payload size.
</t>
<t>
DTLS does not detect STARTTLS replay.
A DTLS session can be terminated by sending a TLS closure alert.
Subsequent RPC messages passing between the client and server
will no longer be protected until a new TLS session is established.
</t>
</section>

<section
 title="Operation on Other Transports"
 anchor="section:BFCC24B1-E6D4-4ABC-A5F3-B71E8E96878F">
<t>
RPC-over-RDMA can make use of Transport Layer Security
below the RDMA transport layer
<xref target="RFC8166"/>.
The exact mechanism is not within the scope of this document.
Because there might not be other provisions to exchange client and server certificates,
authentication material would need to be provided by facilites within a future
RPC-over-RDMA transport.
</t>
<t>
Transports that provide intrinsic TLS-level security (e.g., QUIC) would
need to be addressed separately from the current document.
In such cases, use of TLS would not be opportunitic as it is for TCP or UDP.
</t>
</section>

</section>

<section
 title="TLS Peer Authentication"
 anchor="section:936921ed-67bb-46bf-b316-6740e07f6652">
<t>
Peer authentication can be performed by TLS using any of the
following mechanisms:
</t>

<section
 title="X.509 Certificates Using PKIX trust"
 anchor="section:7A68F518-2C02-4705-8218-4F13E51372F4">
<t>
Implementations are REQUIRED to support this mechanism.
In this mode, an RPC peer is uniquely identified
by the tuple (serial number of presented certificate;Issuer).
<list style="symbols">
<t>
Implementations MUST allow the configuration of a list of
trusted Certification Authorities for incoming connections.
</t>
<t>
Certificate validation MUST include the verification rules as per
<xref target="RFC5280"/>.
</t>
<t>
Implementations SHOULD indicate their trusted Certification
Authorities (CAs).
</t>
<t>
Peer validation always includes a check on whether the
locally configured expected DNS name or IP address of the
server that is contacted matches its presented certificate.
DNS names and IP addresses can be contained in the Common
Name (CN) or subjectAltName entries.
For verification, only one of these entries is to be considered.
The following precedence applies: for DNS name validation,
subjectAltName:DNS has precedence over CN; for IP address
validation, subjectAltName:iPAddr has precedence over CN.
Implementors of this specification are advised to read
Section 6 of
<xref target="RFC6125"/>
for more details on DNS name validation.
</t>
<t>
Implementations MAY allow the configuration of a set of
additional properties of the certificate to check for a
peer's authorization to communicate
(e.g., a set of allowed values in subjectAltName:URI
or a set of allowed X509v3 Certificate Policies).
</t>
<t>
When the configured trust base changes (e.g., removal of a
CA from the list of trusted CAs; issuance of a new CRL for
a given CA), implementations MAY renegotiate the TLS
session to reassess the connecting peer's continued
authorization.
</t>
</list>
</t>
<t>
Authenticating a connecting entity does not mean the
RPC server necessarily wants to communicate with that client.
For example, if the Issuer is not in a trusted set of Issuers,
the RPC server may decline to perform RPC transactions
with this client.
Implementations that want to support a wide variety of trust models
should expose as many details of the presented certificate to the
administrator as possible so that the trust model can be implemented
by the administrator.
As a suggestion, at least the following
parameters of the X.509 client certificate SHOULD be exposed:
<list style="symbols">
<t>
Originating IP address
</t>
<t>
Certificate Fingerprint
</t>
<t>
Issuer
</t>
<t>
Subject
</t>
<t>
all X509v3 Extended Key Usage
</t>
<t>
all X509v3 Subject Alternative Name
</t>
<t>
all X509v3 Certificate Policies
</t>
</list>
</t>
</section>

<section
 title="X.509 Certificates Using Fingerprints"
 anchor="section:15B9BEE9-9D2F-49B7-900E-0BA9BCE9CB27">
<t>
This mechanism is OPTIONAL to implement.
In this mode, an RPC peer is uniquely identified
by the fingerprint of the presented certificate.
</t>
<t>
Implementations SHOULD allow the configuration of a list
of trusted certificates,
identified via fingerprint of the DER encoded certificate octets.
Implementations MUST support SHA-256
<xref target="SHA2"/>
or stronger as the hash algorithm for the fingerprint.
</t>
</section>

<section
 title="Pre-Shared Keys"
 anchor="section:6DA9ED5F-BAD9-4126-95B7-E2331655A01E">
<t>
This mechanism is OPTIONAL to implement.
In this mode, an RPC peer is uniquely identified by key material
that has been shared out-of-band or by a previous TLS-protected
connection (see
<xref target="RFC8446"/> Section 2.2).
At least the following parameters of the TLS connection SHOULD be exposed:
<list style="symbols">
<t>
Originating IP address
</t>
<t>
TLS Identifier
</t>
</list>
</t>
</section>

<section
 title="Token Binding"
 anchor="section:CBA3E016-B160-4C37-85CA-8D467A6AFE83">
<t>
This mechanism is OPTIONAL to implement.
In this mode, an RPC peer is uniquely identified by a token.
</t>
<t>
Versions of TLS subsequent to TLS 1.2 feature a token binding
mechanism which is nominally more secure than using certificates.
This is discussed in further detail in
<xref target="RFC8471"/>.
</t>
</section>

</section>

</section>

<!-- RFC Editor:
Please remove the following section and the reference to RFC 7942
before this document is published.
-->
<section
 title="Implementation Status"
 anchor="section:88BBA4D6-ED42-4FE6-A208-9D277B68729A">
<t>
This section records the status of known implementations of the
protocol defined by this specification at the time of posting of
this Internet-Draft, and is based on a proposal described in
<xref target="RFC7942"/>.
The description of implementations in this section is
intended to assist the IETF in its decision processes in
progressing drafts to RFCs.
</t>
<t>
Please note that the listing of any individual implementation here
does not imply endorsement by the IETF.
Furthermore, no effort has been spent to verify the information
presented here that was supplied by IETF contributors.
This is not intended as, and must not be construed to be, a
catalog of available implementations or their features.
Readers are advised to note that other implementations may exist.
</t>

<section
 title="DESY NFS server"
 anchor="section:94AA7844-E393-4353-A35D-DA01D13C909B">
<t>
<list style="hanging" hangIndent="11">
<t hangText="Organization:">
DESY
</t>
<t hangText="URL:">
https://desy.de
</t>
<t hangText="Maturity:">
Prototype software based on early versions of this document.
</t>
<t hangText="Coverage:">
The bulk of this specification is implemented.
The use of DTLS functionality is not implemented.
</t>
<t hangText="Licensing:">
LGPL
</t>
<t hangText="Implementation experience:">
No comments from implementors.
</t>
</list>
</t>
</section>

<section
 title="Hammerspace NFS server"
 anchor="section:B387F281-958F-470D-B4D4-1D85907B89F1">
<t>
<list style="hanging" hangIndent="11">
<t hangText="Organization:">
Hammerspace
</t>
<t hangText="URL:">
https://hammerspace.com
</t>
<t hangText="Maturity:">
Prototype software based on early versions of this document.
</t>
<t hangText="Coverage:">
The bulk of this specification is implemented.
The use of DTLS functionality is not implemented.
</t>
<t hangText="Licensing:">
Proprietary
</t>
<t hangText="Implementation experience:">
No comments from implementors.
</t>
</list>
</t>
</section>

<section
 title="Linux NFS server and client"
 anchor="section:BF03B3A2-4483-4404-9E7A-F60FCD850F31">
<t>
<list style="hanging" hangIndent="11">
<t hangText="Organization:">
The Linux Foundation
</t>
<t hangText="URL:">
https://www.kernel.org
</t>
<t hangText="Maturity:">
Prototype software based on early versions of this document.
</t>
<t hangText="Coverage:">
The bulk of this specification is implemented.
The use of DTLS functionality is not implemented.
</t>
<t hangText="Licensing:">
GPLv2
</t>
<t hangText="Implementation experience:">
No comments from implementors.
</t>
</list>
</t>
</section>

</section>

<section
 title="Security Considerations"
 anchor="section:2ae49383-e6b2-4830-8407-995febf727f2">
<t>
One purpose of the mechanism described in this document
is to protect RPC-based applications against threats to
the privacy of RPC transactions and RPC user identities.
A taxonomy of these threats appears in Section 5 of
<xref target="RFC6973"/>.
In addition, Section 6 of
<xref target="RFC7525"/>
contains a detailed discussion
of technologies used in conjunction with TLS.
Implementers should familiarize themselves with these materials.
</t>

<section
 title="Limitations of an Opportunistic Approach"
 anchor="section:51737BB5-2B65-441E-AD1D-7EBF5123C079">
<t>
The purpose of using an explicitly opportunistic approach
is to enable interoperation with implementations that do not
support RPC-over-TLS.
A range of options is allowed by this approach,
from
"no peer authentication or encryption"
to
"server-only authentication with encryption"
to
"mutual authentication with encryption".
The actual security level may indeed be selected
based on a policy and without user intervention.
</t>
<t>
In cases where interoperability is a priority,
the security benefits of TLS are partially or entirely waived.
Implementations of the mechanism described in this document
must take care to accurately represent to all RPC consumers
the level of security that is actually in effect.
In addition, implementations are REQUIRED to provide an audit log
of RPC-over-TLS security mode selection.
</t>

<section
 title="STRIPTLS Attacks"
 anchor="section:8894bdd2-0e0b-47a3-a2cb-70e4d93b55b0">
<t>
A classic form of attack on network protocols that initiate an association
in plain-text to discover support for TLS is a man-in-the-middle
that alters the plain-text handshake to make it appear as though
TLS support is not available on one or both peers.
Clients implementers can choose from the following to mitigate
STRIPTLS attacks:
<list style="symbols">
<t>
A TLSA record
<xref target="RFC6698"/>
can alert clients that TLS is expected to work, and
provides a binding of hostname to x.509 identity.
If TLS cannot be negotiated or authentication fails,
the client disconnects and reports the problem.
</t>
<t>
Client security policy can be configured to require
that a TLS session is established on every connection.
If an attacker spoofs the handshake, the client disconnects
and reports the problem.
If TLSA records are not available, this approach is strongly encouraged.
</t>
</list>
</t>
</section>

</section>

<section
 title="Multiple User Identity Realms"
 anchor="section:B9F8A982-CB0E-40FC-9460-680E89DB0001">
<t>
To maintain the privacy of RPC users on a single client belonging
to multiple distinct security realms,
the client MUST establish an independent TLS session
for each user identity domain, each using a distinct globally unique identity.
The purpose of this separation is to prevent even privileged users in each
security realm from monitoring RPC traffic emitted on behalf of users in
other security realms on the same peer.
</t>
</section>

<section
 title="Security Considerations for AUTH_SYS on TLS"
 anchor="section:552b02a0-f19e-4b46-809c-672a6ae931a1">
<t>
The use of a TLS-protected transport when
the AUTH_SYS authentication flavor is in use
addresses a number of longstanding weaknesses
(as detailed in
<xref target="section:c7fb9db5-5f4f-45ad-8bf7-74ffca08bebb"/>).
TLS augments AUTH_SYS by providing both integrity protection
and a privacy service that AUTH_SYS lacks.
This protects data payloads, RPC headers, and
user identities against monitoring or alteration while in transit.
TLS guards against the insertion or deletion of messages,
thus also ensuring the integrity of the message stream
between RPC client and server.
</t>
<t>
The use of TLS enables strong authentication of the communicating
RPC peers, providing a degree of non-repudiation.
When AUTH_SYS is used with TLS but the RPC client is unauthenticated,
the RPC server is still acting on RPC requests for which there is
no trustworthy authentication.
In-transit traffic is protected, but the RPC client itself can still
misrepresent user identity without server detection.
This is an improvement from AUTH_SYS without encryption,
but it leaves a critical security exposure.
</t>
<t>
In light of the above, it is RECOMMENDED that when AUTH_SYS is used,
each RPC client should present host authentication material
to RPC servers to prove that the client is a known one.
The server can then make a determination whether the UIDs and GIDs
in AUTH_SYS requests from that client can be accepted.
</t>
<t>
The use of TLS does not enable detection of compromise on RPC clients
that leads to impersonation of RPC users.
In addition, there continues to be a requirement that the mapping of 32-bit user
and group ID values to user identities is the same on both the RPC
client and server.
</t>
</section>

<section
 title="Best Security Policy Practices"
 anchor="section:55D006D3-8CA6-4D7F-AF0D-BFB0FFEF7595">
<t>
To achieve the strongest possible security with RPC-over-TLS,
RPC-over-TLS implementations and deployments are
strongly encouraged
to adhere to these policies:
<list style="hanging">
<t hangText="When using AUTH_NULL or AUTH_SYS:">
<vspace/>
Both peers are required to have DNS TLSA records and certificate material;
a policy that requires mutual peer authentication and
rejection of a connection when host authentication fails.
</t>
<t hangText="When using RPCSEC_GSS:">
<vspace/>
GSS/Kerberos provides adequate host authentication already;
a policy that requires GSS mutual authentication and
rejection of a connection when host authentication fails.
GSS integrity and privacy services should be disabled
in favor of TLS encryption without peer authentication.
</t>
</list>
</t>

</section>

</section>

<section
 title="IANA Considerations"
 anchor="section:7b126473-2a13-453b-9bca-66bc11b7b018">
<t>
In accordance with Section 6 of
<xref target="RFC7301"/>,
the authors request that IANA allocate the following value
in the "Application-Layer Protocol Negotiation (ALPN) Protocol IDs" registry.
The "sunrpc" string identifies SunRPC when used over TLS.
<list style="hanging">
<t hangText="Protocol:">
<vspace/>
SunRPC
</t>
<t hangText="Identification Sequence:">
<vspace/>
0x73 0x75 0x6e 0x72 0x70 0x63 ("sunrpc")
</t>
<t hangText="Reference:">
<vspace/>
RFC-TBD
</t>
</list>
</t>
<!-- RFC Editor:
Please replace RFC-TBD with the RFC number assigned to this document.
-->
</section>

</middle>

<back>

<references title="Normative References">
<?rfc include="reference.RFC.2119.xml"?>
<?rfc include="reference.RFC.4279.xml"?>
<?rfc include="reference.RFC.5280.xml"?>
<?rfc include="reference.RFC.5531.xml"?>
<?rfc include="reference.RFC.6125.xml"?>
<?rfc include="reference.RFC.6347.xml"?>
<?rfc include="reference.RFC.7258.xml"?>
<?rfc include="reference.RFC.7301.xml"?>
<?rfc include="reference.RFC.7861.xml"?>
<?rfc include="reference.RFC.7942.xml"?>.
<?rfc include="reference.RFC.8174.xml"?>
<?rfc include="reference.RFC.8446.xml"?>

<reference
 anchor="SHA2">
<front>
<title>
Secure Hash Standard
</title>
<author>
</author>
<date month="August" year="2015"/>
</front>
<seriesInfo name="National" value="Institute of Standards and Technology"/>
<seriesInfo name="Federal Information Processing Standards Publication" value="FIPS PUB 180-4"/>
<format type="PDF" target="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf"/>
</reference>

</references>

<references title="Informative References">

<?rfc include="reference.RFC.2203.xml"?>
<?rfc include="reference.RFC.2818.xml"?>
<?rfc include="reference.RFC.6698.xml"?>
<?rfc include="reference.RFC.6973.xml"?>
<?rfc include="reference.RFC.7435.xml"?>
<?rfc include="reference.RFC.7525.xml"?>
<?rfc include="reference.RFC.8166.xml"?>
<?rfc include="reference.RFC.8471.xml"?>

</references>

<section
 title="Known Weaknesses of the AUTH_SYS Authentication Flavor"
 anchor="section:c7fb9db5-5f4f-45ad-8bf7-74ffca08bebb">
<t>
The ONC RPC protocol as specified in
<xref target="RFC5531"/>
provides several modes of security, traditionally
referred to as "authentication flavors",
though some of these flavors provide much more than an authentication service.
We will refer to these as authentication flavors,
security flavors, or simply, flavors.
One of the earliest and most basic flavor is
AUTH_SYS, also known as AUTH_UNIX.
AUTH_SYS is currently specified in Appendix A of
<xref target="RFC5531"/>.
</t>
<t>
AUTH_SYS assumes that both the RPC client and server use POSIX-style
user and group identifiers
(each user and group can be distinctly represented as a 32-bit unsigned integer),
and that both client and server use the same mapping of user and group to integer.
One user ID, one main group ID, and up to 16 supplemental group IDs
are associated with each RPC request.
The combination of these identify the entity on the client that is making
the request.
</t>
<t>
Peers are identified by a string in each RPC request.
RFC 5531 does not specify any requirements for this string other
than that is no longer than 255 octets.
It does not have to be the same from request to request,
nor does it have to match the name of the sending host.
For these reasons, though most implementations do fill in their
hostname in this field, receivers typically ignore its content.
</t>
<t>
RFC 5531 Appendix A contains a brief explanation of security
considerations:
<list style="none">
<t>
It should be noted that use of this flavor of authentication does not
guarantee any security for the users or providers of a service, in
itself.  The authentication provided by this scheme can be considered
legitimate only when applications using this scheme and the network
can be secured externally, and privileged transport addresses are
used for the communicating end-points (an example of this is the use
of privileged TCP/UDP ports in UNIX systems -- note that not all
systems enforce privileged transport address mechanisms).
</t>
</list>
</t>
<t>
It should be clear, therefore, that AUTH_SYS by itself offers little
to no communication security:
<list style="numbers">
<t>
It does not protect the privacy or integrity of RPC requests, users,
or payloads, relying instead on "external" security.
</t>
<t>
It also does not provide actual authentication of RPC peer machines, other
than an unprotected domain name.
</t>
<t>
The use of 32-bit unsigned integers as user and group identifiers
is problematic because these simple data types are
not signed or otherwise verified by any authority.
</t>
<t>
Because the user and group ID fields are not integrity-protected,
AUTH_SYS does not offer non-repudiation.
</t>
</list>
</t>

</section>

<section
 title="Acknowledgments"
 anchor="section:4959412f-37ad-42b8-9169-d477148f81a8"
 numbered="no">
<t>
Special mention goes to Charles Fisher, author of
<eref
 target="https://www.linuxjournal.com/content/encrypting-nfsv4-stunnel-tls">
"Encrypting NFSv4 with Stunnel TLS"
</eref>.
His article inspired the mechanism described in this document.
</t>
<t>
Many thanks to Tigran Mkrtchyan for his work on the DESY prototype
and resulting feedback to this document.
</t>
<t>
Thanks to Derrell Piper for numerous suggestions that
improved both the security of this simple mechanism and
the security-related discussion in this document.
</t>
<t>
The authors are grateful to
Bill Baker,
David Black,
Alan DeKok,
Lars Eggert,
Benjamin Kaduk,
Olga Kornievskaia,
Greg Marsden,
Alex McDonald,
David Noveck,
Justin Mazzola Paluska,
Tom Talpey,
and
Martin Thomson
for their input and support of this work.
</t>
<t>
Lastly, special thanks go to
Transport Area Director Magnus Westerlund,
NFSV4 Working Group Chairs Spencer Shepler and Brian Pawlowski,
and
NFSV4 Working Group Secretary Thomas Haynes
for their guidance and oversight.
</t>
</section>

</back>

</rfc>
